/* tslint:disable */
/* eslint-disable */
/**
 * expert.ai Natural Language API
 * Natural Language API provides a comprehensive set of natural language understanding capabilities based on expert.ai technology: <ul>   <li>Context based document analysis, comprising:</li>   <ul>     <li>Deep linguistic analysis, which, in turn, comprises:</li>     <ul>       <li>Text subdivision</li>       <li>Part-of-speech tagging</li>       <li>Morphological analysis</li>       <li>Lemmatization</li>       <li>Syntactic analysis</li>       <li>Semantic analysis</li>     </ul>     <li>Keyphrase extraction</li>     <li>Named entity recognition</li>     <li>Relation extraction</li>     <li>Sentiment analysis</li>   </ul>   <li>Taxonomy based document classification</li>   <li>Information detection performed by detectors</li> </ul> 
 *
 * The version of the OpenAPI document: v2
 * Contact: api.inquiry@expert.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Request
 * @export
 * @interface AnalysisRequest
 */
export interface AnalysisRequest {
    /**
     * 
     * @type {Document}
     * @memberof AnalysisRequest
     */
    'document': Document;
}
/**
 * Analysis data
 * @export
 * @interface AnalyzeDocument
 */
export interface AnalyzeDocument {
    /**
     * Service version
     * @type {string}
     * @memberof AnalyzeDocument
     */
    'version'?: string;
    /**
     * Analyzed text
     * @type {string}
     * @memberof AnalyzeDocument
     */
    'content'?: string;
    /**
     * Text language
     * @type {string}
     * @memberof AnalyzeDocument
     */
    'language'?: string;
    /**
     * Paragraphs
     * @type {Array<Paragraph>}
     * @memberof AnalyzeDocument
     */
    'paragraphs'?: Array<Paragraph>;
    /**
     * Sentences
     * @type {Array<Sentence>}
     * @memberof AnalyzeDocument
     */
    'sentences'?: Array<Sentence>;
    /**
     * Phrases
     * @type {Array<Phrase>}
     * @memberof AnalyzeDocument
     */
    'phrases'?: Array<Phrase>;
    /**
     * Tokens
     * @type {Array<Token>}
     * @memberof AnalyzeDocument
     */
    'tokens'?: Array<Token>;
    /**
     * Main sentences
     * @type {Array<MainSentence>}
     * @memberof AnalyzeDocument
     */
    'mainSentences'?: Array<MainSentence>;
    /**
     * Main phrases
     * @type {Array<MainPhrase>}
     * @memberof AnalyzeDocument
     */
    'mainPhrases'?: Array<MainPhrase>;
    /**
     * Main lemmas
     * @type {Array<MainLemma>}
     * @memberof AnalyzeDocument
     */
    'mainLemmas'?: Array<MainLemma>;
    /**
     * Main syncons
     * @type {Array<MainSyncon>}
     * @memberof AnalyzeDocument
     */
    'mainSyncons'?: Array<MainSyncon>;
    /**
     * Entities
     * @type {Array<Entity>}
     * @memberof AnalyzeDocument
     */
    'entities'?: Array<Entity>;
    /**
     * Knowledge Graph topics
     * @type {Array<DocumentTopic>}
     * @memberof AnalyzeDocument
     */
    'topics'?: Array<DocumentTopic>;
    /**
     * Knowledge Graph syncons data
     * @type {Array<KnowledgeEntry>}
     * @memberof AnalyzeDocument
     */
    'knowledge'?: Array<KnowledgeEntry>;
    /**
     * Sentiment
     * @type {object}
     * @memberof AnalyzeDocument
     */
    'sentiment'?: object;
    /**
     * Verb-mediated relations
     * @type {Array<Relation>}
     * @memberof AnalyzeDocument
     */
    'relations'?: Array<Relation>;
}
/**
 * Analysis resource response
 * @export
 * @interface AnalyzeResponse
 */
export interface AnalyzeResponse {
    /**
     * Operation completed successfully (true/false)
     * @type {boolean}
     * @memberof AnalyzeResponse
     */
    'success'?: boolean;
    /**
     * Service errors
     * @type {Array<ServiceError>}
     * @memberof AnalyzeResponse
     */
    'errors'?: Array<ServiceError>;
    /**
     * 
     * @type {AnalyzeDocument}
     * @memberof AnalyzeResponse
     */
    'data'?: AnalyzeDocument;
}
/**
 * Atom info
 * @export
 * @interface Atom
 */
export interface Atom {
    /**
     * Zero-based position of the first character of the atom
     * @type {number}
     * @memberof Atom
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the atom
     * @type {number}
     * @memberof Atom
     */
    'end'?: number;
    /**
     * Expert.ai type
     * @type {string}
     * @memberof Atom
     */
    'type'?: string;
    /**
     * Lemma
     * @type {string}
     * @memberof Atom
     */
    'lemma'?: string;
}
/**
 * Categorization data
 * @export
 * @interface CategorizeDocument
 */
export interface CategorizeDocument {
    /**
     * Service version
     * @type {string}
     * @memberof CategorizeDocument
     */
    'version'?: string;
    /**
     * Text language
     * @type {string}
     * @memberof CategorizeDocument
     */
    'language'?: string;
    /**
     * Categories
     * @type {Array<Category>}
     * @memberof CategorizeDocument
     */
    'categories'?: Array<Category>;
}
/**
 * Classification resource response
 * @export
 * @interface CategorizeResponse
 */
export interface CategorizeResponse {
    /**
     * Operation completed successfully (true/false)
     * @type {boolean}
     * @memberof CategorizeResponse
     */
    'success'?: boolean;
    /**
     * Service errors
     * @type {Array<ServiceError>}
     * @memberof CategorizeResponse
     */
    'errors'?: Array<ServiceError>;
    /**
     * 
     * @type {CategorizeDocument}
     * @memberof CategorizeResponse
     */
    'data'?: CategorizeDocument;
}
/**
 * Category
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Category ID
     * @type {string}
     * @memberof Category
     */
    'id'?: string;
    /**
     * Category label
     * @type {string}
     * @memberof Category
     */
    'label'?: string;
    /**
     * Hierarchical path
     * @type {Array<string>}
     * @memberof Category
     */
    'hierarchy'?: Array<string>;
    /**
     * Score assigned to the category to represent its relevance
     * @type {number}
     * @memberof Category
     */
    'score'?: number;
    /**
     * True if the category is deemed particularly relevant
     * @type {boolean}
     * @memberof Category
     */
    'winner'?: boolean;
    /**
     * Name of the software package containing the reference taxonomy
     * @type {string}
     * @memberof Category
     */
    'namespace'?: string;
    /**
     * Score expressed as a percentage of the sum of the scores of all the candidate categories, winners and not (see the **score** property)
     * @type {number}
     * @memberof Category
     */
    'frequency'?: number;
    /**
     * Positions of the portions of text that contributed to the selection of the category
     * @type {Array<DocumentPosition>}
     * @memberof Category
     */
    'positions'?: Array<DocumentPosition>;
}
/**
 * Information about a context
 * @export
 * @interface ContextInfo
 */
export interface ContextInfo {
    /**
     * Context name
     * @type {string}
     * @memberof ContextInfo
     */
    'name'?: string;
    /**
     * Context description
     * @type {string}
     * @memberof ContextInfo
     */
    'description'?: string;
    /**
     * Information about supported languages and available analyses
     * @type {Array<ContextLanguageInfo>}
     * @memberof ContextInfo
     */
    'languages'?: Array<ContextLanguageInfo>;
}
/**
 * Information about a supported language and available analyses
 * @export
 * @interface ContextLanguageInfo
 */
export interface ContextLanguageInfo {
    /**
     * Language code
     * @type {string}
     * @memberof ContextLanguageInfo
     */
    'code'?: string;
    /**
     * Language name
     * @type {string}
     * @memberof ContextLanguageInfo
     */
    'name'?: string;
    /**
     * Available analyses
     * @type {Array<string>}
     * @memberof ContextLanguageInfo
     */
    'analyses'?: Array<string>;
}
/**
 * Available contexts
 * @export
 * @interface ContextsResponse
 */
export interface ContextsResponse {
    /**
     * List of contexts\' information
     * @type {Array<ContextInfo>}
     * @memberof ContextsResponse
     */
    'contexts'?: Array<ContextInfo>;
}
/**
 * A counter index
 * @export
 * @interface CounterIndex
 */
export interface CounterIndex {
    /**
     * 
     * @type {number}
     * @memberof CounterIndex
     */
    'total'?: number;
}
/**
 * Dependency info
 * @export
 * @interface Dependency
 */
export interface Dependency {
    /**
     * Zero-based cardinal number of the token
     * @type {number}
     * @memberof Dependency
     */
    'id'?: number;
    /**
     * Number of the head token
     * @type {number}
     * @memberof Dependency
     */
    'head'?: number;
    /**
     * (<a href=\'https://universaldependencies.org/u/dep/#universal-dependency-relations\' target=\'_blank\'>Dependency relation</a> between the token and the head token
     * @type {string}
     * @memberof Dependency
     */
    'label'?: string;
}
/**
 * Base document for all detectors
 * @export
 * @interface DetectorBaseDocument
 */
export interface DetectorBaseDocument {
    /**
     * Service version
     * @type {string}
     * @memberof DetectorBaseDocument
     */
    'version'?: string;
    /**
     * Analyzed text
     * @type {string}
     * @memberof DetectorBaseDocument
     */
    'content'?: string;
    /**
     * Text language
     * @type {string}
     * @memberof DetectorBaseDocument
     */
    'language'?: string;
    /**
     * Paragraphs
     * @type {Array<Paragraph>}
     * @memberof DetectorBaseDocument
     */
    'paragraphs'?: Array<Paragraph>;
    /**
     * Sentences
     * @type {Array<Sentence>}
     * @memberof DetectorBaseDocument
     */
    'sentences'?: Array<Sentence>;
    /**
     * Phrases
     * @type {Array<Phrase>}
     * @memberof DetectorBaseDocument
     */
    'phrases'?: Array<Phrase>;
    /**
     * Tokens
     * @type {Array<Token>}
     * @memberof DetectorBaseDocument
     */
    'tokens'?: Array<Token>;
    /**
     * Entities
     * @type {Array<Entity>}
     * @memberof DetectorBaseDocument
     */
    'entities'?: Array<Entity>;
    /**
     * Knowledge Graph syncons\' data
     * @type {Array<KnowledgeEntry>}
     * @memberof DetectorBaseDocument
     */
    'knowledge'?: Array<KnowledgeEntry>;
    /**
     * Categories
     * @type {Array<Category>}
     * @memberof DetectorBaseDocument
     */
    'categories'?: Array<Category>;
    /**
     * Extracted information
     * @type {Array<Extraction>}
     * @memberof DetectorBaseDocument
     */
    'extractions'?: Array<Extraction>;
}
/**
 * Summary information about a detector
 * @export
 * @interface DetectorInfo
 */
export interface DetectorInfo {
    /**
     * Detector name
     * @type {string}
     * @memberof DetectorInfo
     */
    'name'?: string;
    /**
     * Detector description
     * @type {string}
     * @memberof DetectorInfo
     */
    'description'?: string;
    /**
     * OpenAPI document describing the use of the detector and its output
     * @type {string}
     * @memberof DetectorInfo
     */
    'contract'?: string;
    /**
     * Supported languages
     * @type {Array<LanguageInfo>}
     * @memberof DetectorInfo
     */
    'languages'?: Array<LanguageInfo>;
}
/**
 * Available detectors
 * @export
 * @interface DetectorsResponse
 */
export interface DetectorsResponse {
    /**
     * List of detectors\' information
     * @type {Array<DetectorInfo>}
     * @memberof DetectorsResponse
     */
    'detectors'?: Array<DetectorInfo>;
}
/**
 * Document
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * The document\'s text
     * @type {string}
     * @memberof Document
     */
    'text': string;
}
/**
 * Position
 * @export
 * @interface DocumentPosition
 */
export interface DocumentPosition {
    /**
     * Zero-based position of the first character
     * @type {number}
     * @memberof DocumentPosition
     */
    'start'?: number;
    /**
     * Zero-based position of the character after the last
     * @type {number}
     * @memberof DocumentPosition
     */
    'end'?: number;
}
/**
 * Knowledge Graph topic info
 * @export
 * @interface DocumentTopic
 */
export interface DocumentTopic {
    /**
     * Language-independent topic ID
     * @type {number}
     * @memberof DocumentTopic
     */
    'id'?: number;
    /**
     * Topic name
     * @type {string}
     * @memberof DocumentTopic
     */
    'label'?: string;
    /**
     * Score assigned to the topic to represent its relevance
     * @type {number}
     * @memberof DocumentTopic
     */
    'score'?: number;
    /**
     * True if the topic is deemed particularly relevant
     * @type {boolean}
     * @memberof DocumentTopic
     */
    'winner'?: boolean;
}
/**
 * Categorization data
 * @export
 * @interface EmotionalTraitsDocument
 */
export interface EmotionalTraitsDocument {
    /**
     * 
     * @type {EmotionalTraitsDocumentExtraData}
     * @memberof EmotionalTraitsDocument
     */
    'extraData'?: EmotionalTraitsDocumentExtraData;
}
/**
 * Extra-data containing main groups
 * @export
 * @interface EmotionalTraitsDocumentExtraData
 */
export interface EmotionalTraitsDocumentExtraData {
    /**
     * Main groups
     * @type {Array<Group>}
     * @memberof EmotionalTraitsDocumentExtraData
     */
    'groups'?: Array<Group>;
}
/**
 * Classification resource response
 * @export
 * @interface EmotionalTraitsResponse
 */
export interface EmotionalTraitsResponse {
    /**
     * Operation completed successfully (true/false)
     * @type {boolean}
     * @memberof EmotionalTraitsResponse
     */
    'success'?: boolean;
    /**
     * Service errors
     * @type {Array<ServiceError>}
     * @memberof EmotionalTraitsResponse
     */
    'errors'?: Array<ServiceError>;
    /**
     * 
     * @type {CategorizeDocument & EmotionalTraitsDocument}
     * @memberof EmotionalTraitsResponse
     */
    'data'?: CategorizeDocument & EmotionalTraitsDocument;
}
/**
 * Entity info
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * Entity type
     * @type {string}
     * @memberof Entity
     */
    'type'?: string;
    /**
     * Base form (lemma) of the entity name
     * @type {string}
     * @memberof Entity
     */
    'lemma'?: string;
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof Entity
     */
    'syncon'?: number;
    /**
     * Positions of the entity\'s mentions
     * @type {Array<DocumentPosition>}
     * @memberof Entity
     */
    'positions'?: Array<DocumentPosition>;
    /**
     * Entity relevance
     * @type {number}
     * @memberof Entity
     */
    'relevance'?: number;
    /**
     * Entity attributes inferred from the context or from the Knowledge Graph
     * @type {Array<InferredAttribute>}
     * @memberof Entity
     */
    'attributes'?: Array<InferredAttribute>;
}
/**
 * Extraction record
 * @export
 * @interface Extraction
 */
export interface Extraction {
    /**
     * Software package name
     * @type {string}
     * @memberof Extraction
     */
    'namespace'?: string;
    /**
     * Extraction record template
     * @type {string}
     * @memberof Extraction
     */
    'template'?: string;
    /**
     * Extraction record fields
     * @type {Array<ExtractionFields>}
     * @memberof Extraction
     */
    'fields'?: Array<ExtractionFields>;
}
/**
 * 
 * @export
 * @interface ExtractionFields
 */
export interface ExtractionFields {
    /**
     * Field name
     * @type {string}
     * @memberof ExtractionFields
     */
    'name'?: string;
    /**
     * Field value
     * @type {string}
     * @memberof ExtractionFields
     */
    'value'?: string;
    /**
     * Positions of parts of the text corresponding to the field value
     * @type {Array<DocumentPosition>}
     * @memberof ExtractionFields
     */
    'positions'?: Array<DocumentPosition>;
}
/**
 * A GeoJSON object with the type `Feature` is a feature object. * A feature object must have a member with the name `geometry`. The value of the geometry member is a geometry object as defined above or a JSON null value. * A feature object must have a member with the name `properties`. The value of the properties member is an object (any JSON object or a JSON null value). * If a feature has a commonly used identifier, that identifier should be included as a member of the feature object with the name `id`.
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'type'?: FeatureTypeEnum;
    /**
     * 
     * @type {Point}
     * @memberof Feature
     */
    'geometry': Point;
    /**
     * 
     * @type {FeatureProperties}
     * @memberof Feature
     */
    'properties': FeatureProperties;
}

/**
    * @export
    * @enum {string}
    */
export enum FeatureTypeEnum {
    Feature = 'Feature'
}

/**
 * A GeoJSON object with the type `FeatureCollection` is a feature collection object. An object of type `FeatureCollection` must have a member with the name `features`. The value corresponding to `features` is an array. Each element in the array is a feature object as defined above.
 * @export
 * @interface FeatureCollection
 */
export interface FeatureCollection {
    /**
     * 
     * @type {string}
     * @memberof FeatureCollection
     */
    'type'?: FeatureCollectionTypeEnum;
    /**
     * 
     * @type {Array<Feature>}
     * @memberof FeatureCollection
     */
    'features': Array<Feature>;
    /**
     * To include information on the coordinate range for geometries, features, or feature collections, a GeoJSON object may have a member named `bbox`. The value of the bbox member must be a 2*n array where n is the number of dimensions represented in the contained geometries, with the lowest values for all axes followed by the highest values. The axes order of a bbox follows the axes order of geometries. In addition, the coordinate reference system for the bbox is assumed to match the coordinate reference system of the GeoJSON object of which it is a member. 
     * @type {Array<number>}
     * @memberof FeatureCollection
     */
    'bbox'?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum FeatureCollectionTypeEnum {
    FeatureCollection = 'FeatureCollection'
}

/**
 * The `properties` member is an object containing application-specific attributes of the feature. 
 * @export
 * @interface FeatureProperties
 */
export interface FeatureProperties {
    /**
     * The GeoTax id
     * @type {string}
     * @memberof FeatureProperties
     */
    'id'?: string;
    /**
     * The geonameid of place
     * @type {string}
     * @memberof FeatureProperties
     */
    'geonameid'?: string;
    /**
     * The Geo Place name
     * @type {string}
     * @memberof FeatureProperties
     */
    'name'?: string;
}
/**
 * This schema is solely an abstract definition to share the common GeoJSON attributes to the concrete GeoJSON types. 
 * @export
 * @interface GeoJsonBase
 */
export interface GeoJsonBase {
    /**
     * 
     * @type {FeatureCollection}
     * @memberof GeoJsonBase
     */
    'type'?: FeatureCollection;
}
/**
 * Classification results
 * @export
 * @interface GeoTaxDocument
 */
export interface GeoTaxDocument {
    /**
     * 
     * @type {GeoTaxDocumentExtraData}
     * @memberof GeoTaxDocument
     */
    'extraData'?: GeoTaxDocumentExtraData;
}
/**
 * Extra-data containing GeoJSON data
 * @export
 * @interface GeoTaxDocumentExtraData
 */
export interface GeoTaxDocumentExtraData {
    /**
     * 
     * @type {GeoJsonBase}
     * @memberof GeoTaxDocumentExtraData
     */
    'geojson'?: GeoJsonBase;
}
/**
 * Resource response
 * @export
 * @interface GeoTaxResponse
 */
export interface GeoTaxResponse {
    /**
     * Operation completed successfully (true/false)
     * @type {boolean}
     * @memberof GeoTaxResponse
     */
    'success'?: boolean;
    /**
     * Service errors
     * @type {Array<ServiceError>}
     * @memberof GeoTaxResponse
     */
    'errors'?: Array<ServiceError>;
    /**
     * 
     * @type {CategorizeDocument & GeoTaxDocument}
     * @memberof GeoTaxResponse
     */
    'data'?: CategorizeDocument & GeoTaxDocument;
}
/**
 * Group of emotional traits
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * ID of the category corresponding to the group inside the taxonomy
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * Label of the category corresponding to the group inside the taxonomy
     * @type {string}
     * @memberof Group
     */
    'label'?: string;
    /**
     * Group rank
     * @type {number}
     * @memberof Group
     */
    'position'?: number;
}
/**
 * Inferred attribute
 * @export
 * @interface InferredAttribute
 */
export interface InferredAttribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof InferredAttribute
     */
    'attribute'?: string;
    /**
     * Lemma
     * @type {string}
     * @memberof InferredAttribute
     */
    'lemma'?: string;
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof InferredAttribute
     */
    'syncon'?: number;
    /**
     * Attribute type
     * @type {string}
     * @memberof InferredAttribute
     */
    'type'?: string;
    /**
     * Attribute\'s attributes
     * @type {Array<InferredAttribute>}
     * @memberof InferredAttribute
     */
    'attributes'?: Array<InferredAttribute>;
}
/**
 * Knowledge Graph data for a syncon
 * @export
 * @interface KnowledgeEntry
 */
export interface KnowledgeEntry {
    /**
     * Syncon ID
     * @type {number}
     * @memberof KnowledgeEntry
     */
    'syncon'?: number;
    /**
     * Textual rendering of the general conceptual category for the token in the Knowledge Graph
     * @type {string}
     * @memberof KnowledgeEntry
     */
    'label'?: string;
    /**
     * Syncon extended properties
     * @type {Array<Property>}
     * @memberof KnowledgeEntry
     */
    'properties'?: Array<Property>;
}
/**
 * Information about a supported language
 * @export
 * @interface LanguageInfo
 */
export interface LanguageInfo {
    /**
     * Language code
     * @type {string}
     * @memberof LanguageInfo
     */
    'code'?: string;
    /**
     * Language name
     * @type {string}
     * @memberof LanguageInfo
     */
    'name'?: string;
}
/**
 * Main lemma info
 * @export
 * @interface MainLemma
 */
export interface MainLemma {
    /**
     * Lemma
     * @type {string}
     * @memberof MainLemma
     */
    'value'?: string;
    /**
     * Score assigned to the lemma to represent its relevance
     * @type {number}
     * @memberof MainLemma
     */
    'score'?: number;
    /**
     * Positions of lemma occurrences
     * @type {Array<DocumentPosition>}
     * @memberof MainLemma
     */
    'positions'?: Array<DocumentPosition>;
}
/**
 * Main phrase info
 * @export
 * @interface MainPhrase
 */
export interface MainPhrase {
    /**
     * Phrase text
     * @type {string}
     * @memberof MainPhrase
     */
    'value'?: string;
    /**
     * Score assigned to the phrase to represent its relevance
     * @type {number}
     * @memberof MainPhrase
     */
    'score'?: number;
    /**
     * Positions of phrase occurrences
     * @type {Array<DocumentPosition>}
     * @memberof MainPhrase
     */
    'positions'?: Array<DocumentPosition>;
}
/**
 * Main sentence
 * @export
 * @interface MainSentence
 */
export interface MainSentence {
    /**
     * Sentence text
     * @type {string}
     * @memberof MainSentence
     */
    'value'?: string;
    /**
     * Score assigned to the sentence to represent its relevance
     * @type {number}
     * @memberof MainSentence
     */
    'score'?: number;
    /**
     * Zero-based position of the first character of the sentence
     * @type {number}
     * @memberof MainSentence
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the sentence
     * @type {number}
     * @memberof MainSentence
     */
    'end'?: number;
}
/**
 * Main syncon info
 * @export
 * @interface MainSyncon
 */
export interface MainSyncon {
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof MainSyncon
     */
    'syncon'?: number;
    /**
     * Lemma
     * @type {string}
     * @memberof MainSyncon
     */
    'lemma'?: string;
    /**
     * Score assigned to the syncon to represent its relevance
     * @type {number}
     * @memberof MainSyncon
     */
    'score'?: number;
    /**
     * Positions of the expressions of the syncon
     * @type {Array<DocumentPosition>}
     * @memberof MainSyncon
     */
    'positions'?: Array<DocumentPosition>;
}
/**
 * Bank account
 * @export
 * @interface PIIBankAccount
 */
export interface PIIBankAccount {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIBankAccount
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIBankAccount
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIBankAccount
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIBankAccount
     */
    'IBAN'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIBankAccount
     */
    'IBANcountry'?: string;
}
/**
 * 
 * @export
 * @interface PIIBankAccountAllOf
 */
export interface PIIBankAccountAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIBankAccountAllOf
     */
    'IBAN'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIBankAccountAllOf
     */
    'IBANcountry'?: string;
}
/**
 * Type with properties inherited by all JSON-LD graph PII types
 * @export
 * @interface PIIBaseItem
 */
export interface PIIBaseItem {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIBaseItem
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIBaseItem
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIBaseItem
     */
    'matches'?: Array<object>;
}
/**
 * PII Specific Document properties
 * @export
 * @interface PIIDocument
 */
export interface PIIDocument {
    /**
     * 
     * @type {PIIExtraData}
     * @memberof PIIDocument
     */
    'extraData'?: PIIExtraData;
}
/**
 * PII Extra Data
 * @export
 * @interface PIIExtraData
 */
export interface PIIExtraData {
    /**
     * 
     * @type {PIIJSONLD}
     * @memberof PIIExtraData
     */
    'JSON-LD'?: PIIJSONLD;
}
/**
 * Credit card
 * @export
 * @interface PIIFinancialProduct
 */
export interface PIIFinancialProduct {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIFinancialProduct
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIFinancialProduct
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIFinancialProduct
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIFinancialProduct
     */
    'creditDebitNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIFinancialProduct
     */
    'CVV'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIFinancialProduct
     */
    'expirationDate'?: string;
}
/**
 * 
 * @export
 * @interface PIIFinancialProductAllOf
 */
export interface PIIFinancialProductAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIFinancialProductAllOf
     */
    'creditDebitNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIFinancialProductAllOf
     */
    'CVV'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIFinancialProductAllOf
     */
    'expirationDate'?: string;
}
/**
 * Internet Protocol (IP) address
 * @export
 * @interface PIIIP
 */
export interface PIIIP {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIIP
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIIP
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIIP
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIIP
     */
    'IP'?: string;
}
/**
 * 
 * @export
 * @interface PIIIPAllOf
 */
export interface PIIIPAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIIPAllOf
     */
    'IP'?: string;
}
/**
 * @type PIIItem
 * Personally Identifiable Information (PII) item
 * @export
 */
export type PIIItem = PIIBankAccount | PIIFinancialProduct | PIIIP | PIIPerson | PIIPostalAddress | PIIURL | PIIemail | PIItelephone;

/**
 * JSON-LD format output
 * @export
 * @interface PIIJSONLD
 */
export interface PIIJSONLD {
    /**
     * 
     * @type {PIIJSONLDContext}
     * @memberof PIIJSONLD
     */
    '@context'?: PIIJSONLDContext;
    /**
     * JSON-LD graph data
     * @type {Array<PIIItem>}
     * @memberof PIIJSONLD
     */
    '@graph'?: Array<PIIItem>;
}
/**
 * JSON-LD context
 * @export
 * @interface PIIJSONLDContext
 */
export interface PIIJSONLDContext {
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    '@version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'schema'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'matches'?: string;
    /**
     * 
     * @type {PIIJSONLDContextStart}
     * @memberof PIIJSONLDContext
     */
    'start'?: PIIJSONLDContextStart;
    /**
     * 
     * @type {PIIJSONLDContextStart}
     * @memberof PIIJSONLDContext
     */
    'end'?: PIIJSONLDContextStart;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'additionalProperty'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'URL'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'IP'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'IBAN'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'IBANcountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'postalAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'creditDebitNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'CVV'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'deathDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'dateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'telephone'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'streetAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'addressCountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'addressLocality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'addressRegion'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'person'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'age'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'birthPlace'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'deathPlace'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContext
     */
    'postOfficeBoxNumber'?: string;
}
/**
 * 
 * @export
 * @interface PIIJSONLDContextStart
 */
export interface PIIJSONLDContextStart {
    /**
     * 
     * @type {string}
     * @memberof PIIJSONLDContextStart
     */
    '@id'?: string;
}
/**
 * Person
 * @export
 * @interface PIIPerson
 */
export interface PIIPerson {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIPerson
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIPerson
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIPerson
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'age'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'birthPlace'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'deathDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'deathPlace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PIIPerson
     */
    'dateTime'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PIIPerson
     */
    'person'?: string;
}
/**
 * 
 * @export
 * @interface PIIPersonAllOf
 */
export interface PIIPersonAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'age'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'birthPlace'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'deathDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'deathPlace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PIIPersonAllOf
     */
    'dateTime'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PIIPersonAllOf
     */
    'person'?: string;
}
/**
 * Postal address
 * @export
 * @interface PIIPostalAddress
 */
export interface PIIPostalAddress {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIPostalAddress
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIPostalAddress
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIPostalAddress
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'streetAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'addressCountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'addressLocality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'addressRegion'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'postOfficeBoxNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddress
     */
    'postalCode'?: string;
}
/**
 * 
 * @export
 * @interface PIIPostalAddressAllOf
 */
export interface PIIPostalAddressAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'streetAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'addressCountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'addressLocality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'addressRegion'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'postOfficeBoxNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PIIPostalAddressAllOf
     */
    'postalCode'?: string;
}
/**
 * Detector\'s response
 * @export
 * @interface PIIResponse
 */
export interface PIIResponse {
    /**
     * Success flag
     * @type {boolean}
     * @memberof PIIResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ServiceError}
     * @memberof PIIResponse
     */
    'error'?: ServiceError;
    /**
     * 
     * @type {DetectorBaseDocument & PIIDocument}
     * @memberof PIIResponse
     */
    'data'?: DetectorBaseDocument & PIIDocument;
}
/**
 * URL
 * @export
 * @interface PIIURL
 */
export interface PIIURL {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIURL
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIURL
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIURL
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIURL
     */
    'URL'?: string;
}
/**
 * 
 * @export
 * @interface PIIURLAllOf
 */
export interface PIIURLAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIURLAllOf
     */
    'URL'?: string;
}
/**
 * E-mail address
 * @export
 * @interface PIIemail
 */
export interface PIIemail {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIIemail
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIIemail
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIIemail
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIIemail
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface PIIemailAllOf
 */
export interface PIIemailAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIIemailAllOf
     */
    'email'?: string;
}
/**
 * Phone number
 * @export
 * @interface PIItelephone
 */
export interface PIItelephone {
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof PIItelephone
     */
    '@type'?: string;
    /**
     * JSON-LD graph item id
     * @type {string}
     * @memberof PIItelephone
     */
    '@id'?: string;
    /**
     * Text matches of items\' properties
     * @type {Array<object>}
     * @memberof PIItelephone
     */
    'matches'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PIItelephone
     */
    'telephone'?: string;
}
/**
 * 
 * @export
 * @interface PIItelephoneAllOf
 */
export interface PIItelephoneAllOf {
    /**
     * 
     * @type {string}
     * @memberof PIItelephoneAllOf
     */
    'telephone'?: string;
}
/**
 * Paragraph info
 * @export
 * @interface Paragraph
 */
export interface Paragraph {
    /**
     * Zero-based position of the first character of the paragraph
     * @type {number}
     * @memberof Paragraph
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the paragraph
     * @type {number}
     * @memberof Paragraph
     */
    'end'?: number;
    /**
     * Indexes (in the `sentences` array) of the sentences that make up the paragraph
     * @type {Set<number>}
     * @memberof Paragraph
     */
    'sentences'?: Set<number>;
}
/**
 * A \'per sentence\' index
 * @export
 * @interface PerSentenceIndex
 */
export interface PerSentenceIndex {
    /**
     * 
     * @type {number}
     * @memberof PerSentenceIndex
     */
    'mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerSentenceIndex
     */
    'standardDeviation'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerSentenceIndex
     */
    'meanAbsoluteDeviation'?: number;
}
/**
 * Phrase info
 * @export
 * @interface Phrase
 */
export interface Phrase {
    /**
     * Zero-based position of the first character of the phrase
     * @type {number}
     * @memberof Phrase
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the phrase
     * @type {number}
     * @memberof Phrase
     */
    'end'?: number;
    /**
     * Indexes (in the `tokens` array) of the tokens that make up the phrase
     * @type {Set<number>}
     * @memberof Phrase
     */
    'tokens'?: Set<number>;
    /**
     * Phrase type
     * @type {string}
     * @memberof Phrase
     */
    'type'?: string;
}
/**
 * For type `Point`, the `coordinates` member must be a single position. 
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    'type'?: PointTypeEnum;
    /**
     * lat long coordinates
     * @type {number}
     * @memberof Point
     */
    'coordinates'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PointTypeEnum {
    Point = 'Point'
}

/**
 * Syncon property
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * Property type
     * @type {string}
     * @memberof Property
     */
    'type'?: string;
    /**
     * Property value
     * @type {string}
     * @memberof Property
     */
    'value'?: string;
}
/**
 * A readability index
 * @export
 * @interface ReadabilityIndex
 */
export interface ReadabilityIndex {
    /**
     * 
     * @type {string}
     * @memberof ReadabilityIndex
     */
    '@type'?: string;
    /**
     * Index name
     * @type {string}
     * @memberof ReadabilityIndex
     */
    'name'?: string;
    /**
     * Index value
     * @type {number}
     * @memberof ReadabilityIndex
     */
    'value'?: number;
    /**
     * Degree of difficulty
     * @type {string}
     * @memberof ReadabilityIndex
     */
    'readabilityLevel'?: string;
}
/**
 * In a relation, a term that\'s directly or indirectly related to the verb
 * @export
 * @interface RelatedItem
 */
export interface RelatedItem {
    /**
     * Verb-item relation
     * @type {string}
     * @memberof RelatedItem
     */
    'relation'?: string;
    /**
     * Item text
     * @type {string}
     * @memberof RelatedItem
     */
    'text'?: string;
    /**
     * Lemma
     * @type {string}
     * @memberof RelatedItem
     */
    'lemma'?: string;
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof RelatedItem
     */
    'syncon'?: number;
    /**
     * 
     * @type {VirtualSyncon}
     * @memberof RelatedItem
     */
    'vsyn'?: VirtualSyncon;
    /**
     * Type
     * @type {string}
     * @memberof RelatedItem
     */
    'type'?: string;
    /**
     * Phrase index in the `phrases` array
     * @type {number}
     * @memberof RelatedItem
     */
    'phrase'?: number;
    /**
     * Relevance
     * @type {number}
     * @memberof RelatedItem
     */
    'relevance'?: number;
    /**
     * Related terms
     * @type {Array<RelatedItem>}
     * @memberof RelatedItem
     */
    'related'?: Array<RelatedItem>;
}
/**
 * Verb-mediated relation
 * @export
 * @interface Relation
 */
export interface Relation {
    /**
     * 
     * @type {RelationVerb}
     * @memberof Relation
     */
    'verb'?: RelationVerb;
    /**
     * Related items
     * @type {Array<RelatedItem>}
     * @memberof Relation
     */
    'related'?: Array<RelatedItem>;
}
/**
 * Verb of a relation
 * @export
 * @interface RelationVerb
 */
export interface RelationVerb {
    /**
     * Verb text
     * @type {string}
     * @memberof RelationVerb
     */
    'text'?: string;
    /**
     * Lemma
     * @type {string}
     * @memberof RelationVerb
     */
    'lemma'?: string;
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof RelationVerb
     */
    'syncon'?: number;
    /**
     * Type
     * @type {string}
     * @memberof RelationVerb
     */
    'type'?: string;
    /**
     * Phrase index in the `phrases` array
     * @type {number}
     * @memberof RelationVerb
     */
    'phrase'?: number;
    /**
     * Relevance
     * @type {number}
     * @memberof RelationVerb
     */
    'relevance'?: number;
}
/**
 * Sentence info
 * @export
 * @interface Sentence
 */
export interface Sentence {
    /**
     * Zero-based position of the first character of the sentence
     * @type {number}
     * @memberof Sentence
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the sentence
     * @type {number}
     * @memberof Sentence
     */
    'end'?: number;
    /**
     * Indexes (in the `phrases` array) of the phrases that make up the sentence
     * @type {Set<number>}
     * @memberof Sentence
     */
    'phrases'?: Set<number>;
}
/**
 * Item or chain of items expressing sentiment
 * @export
 * @interface SentimentItem
 */
export interface SentimentItem {
    /**
     * Lemma
     * @type {string}
     * @memberof SentimentItem
     */
    'lemma'?: string;
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof SentimentItem
     */
    'syncon'?: number;
    /**
     * Item/chain sentiment score
     * @type {number}
     * @memberof SentimentItem
     */
    'sentiment'?: number;
    /**
     * Items expressing sentiment
     * @type {Array<SentimentItem>}
     * @memberof SentimentItem
     */
    'items'?: Array<SentimentItem>;
}
/**
 * Error information
 * @export
 * @interface ServiceError
 */
export interface ServiceError {
    /**
     * Error code
     * @type {string}
     * @memberof ServiceError
     */
    'code'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof ServiceError
     */
    'message'?: string;
}
/**
 * Available taxonomies
 * @export
 * @interface TaxonomiesResponse
 */
export interface TaxonomiesResponse {
    /**
     * List of taxonomies\' information
     * @type {Array<TaxonomyInfo>}
     * @memberof TaxonomiesResponse
     */
    'texonomies'?: Array<TaxonomyInfo>;
}
/**
 * A taxonomy\'s categories tree
 * @export
 * @interface Taxonomy
 */
export interface Taxonomy {
    /**
     * Name of the software package containing the reference taxonomy
     * @type {string}
     * @memberof Taxonomy
     */
    'namespace'?: string;
    /**
     * Categories tree
     * @type {Array<TaxonomyCategory>}
     * @memberof Taxonomy
     */
    'taxonomy'?: Array<TaxonomyCategory>;
}
/**
 * Taxonomy category
 * @export
 * @interface TaxonomyCategory
 */
export interface TaxonomyCategory {
    /**
     * Category ID
     * @type {string}
     * @memberof TaxonomyCategory
     */
    'id'?: string;
    /**
     * Category label
     * @type {string}
     * @memberof TaxonomyCategory
     */
    'label'?: string;
    /**
     * Sub-categories
     * @type {Array<TaxonomyCategory>}
     * @memberof TaxonomyCategory
     */
    'categories'?: Array<TaxonomyCategory>;
}
/**
 * Summary information about a taxonomy
 * @export
 * @interface TaxonomyInfo
 */
export interface TaxonomyInfo {
    /**
     * Taxonomy name
     * @type {string}
     * @memberof TaxonomyInfo
     */
    'name'?: string;
    /**
     * Taxonomy description
     * @type {string}
     * @memberof TaxonomyInfo
     */
    'description'?: string;
    /**
     * OpenAPI document describing extra ways to use the taxonomy and their outputs
     * @type {string}
     * @memberof TaxonomyInfo
     */
    'contract'?: string;
    /**
     * Supported languages
     * @type {Array<LanguageInfo>}
     * @memberof TaxonomyInfo
     */
    'languages'?: Array<LanguageInfo>;
}
/**
 * Taxonomy categories
 * @export
 * @interface TaxonomyResponse
 */
export interface TaxonomyResponse {
    /**
     * Operation completed successfully (true/false)
     * @type {boolean}
     * @memberof TaxonomyResponse
     */
    'success'?: boolean;
    /**
     * Service errors
     * @type {Array<ServiceError>}
     * @memberof TaxonomyResponse
     */
    'errors'?: Array<ServiceError>;
    /**
     * 
     * @type {Array<Taxonomy>}
     * @memberof TaxonomyResponse
     */
    'data'?: Array<Taxonomy>;
}
/**
 * Temporal Information Document properties
 * @export
 * @interface TemporalInformationDocument
 */
export interface TemporalInformationDocument {
    /**
     * 
     * @type {TemporalInformationExtraData}
     * @memberof TemporalInformationDocument
     */
    'extraData'?: TemporalInformationExtraData;
}
/**
 * Temporal Information Extra Data
 * @export
 * @interface TemporalInformationExtraData
 */
export interface TemporalInformationExtraData {
    /**
     * 
     * @type {TemporalInformationJSONLD}
     * @memberof TemporalInformationExtraData
     */
    'JSON-LD'?: TemporalInformationJSONLD;
}
/**
 * An item carrying temporal information
 * @export
 * @interface TemporalInformationItem
 */
export interface TemporalInformationItem {
    /**
     * Unique identifier
     * @type {string}
     * @memberof TemporalInformationItem
     */
    '@id'?: string;
    /**
     * JSON-LD graph item type
     * @type {string}
     * @memberof TemporalInformationItem
     */
    '@type'?: string;
    /**
     * Temporal information expression type, can be \'TimePoint\', \'TimeSpan\' or \'TimeInterval\'
     * @type {string}
     * @memberof TemporalInformationItem
     */
    'name'?: string;
    /**
     * Normalized information
     * @type {string}
     * @memberof TemporalInformationItem
     */
    'value'?: string;
    /**
     * Occurrences of the information in the text
     * @type {Array<TemporalInformationMatch>}
     * @memberof TemporalInformationItem
     */
    'matches'?: Array<TemporalInformationMatch>;
}
/**
 * JSON-LD format output
 * @export
 * @interface TemporalInformationJSONLD
 */
export interface TemporalInformationJSONLD {
    /**
     * JSON-LD context
     * @type {any}
     * @memberof TemporalInformationJSONLD
     */
    '@context'?: any;
    /**
     * 
     * @type {TemporalInformationJSONLDGraph}
     * @memberof TemporalInformationJSONLD
     */
    '@graph'?: TemporalInformationJSONLDGraph;
}
/**
 * JSON-LD graph data
 * @export
 * @interface TemporalInformationJSONLDGraph
 */
export interface TemporalInformationJSONLDGraph {
    /**
     * Detector\'s name
     * @type {string}
     * @memberof TemporalInformationJSONLDGraph
     */
    '@id'?: string;
    /**
     * Temporal information items
     * @type {Array<TemporalInformationItem>}
     * @memberof TemporalInformationJSONLDGraph
     */
    'items'?: Array<TemporalInformationItem>;
}
/**
 * An occurrence of a temporal information in the text
 * @export
 * @interface TemporalInformationMatch
 */
export interface TemporalInformationMatch {
    /**
     * Unique identifier
     * @type {string}
     * @memberof TemporalInformationMatch
     */
    '@id'?: string;
    /**
     * Zero-based position of the first character of the portion of text corresponding to the information occurrence
     * @type {number}
     * @memberof TemporalInformationMatch
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the last of the portion of text corresponding to the information occurrence
     * @type {number}
     * @memberof TemporalInformationMatch
     */
    'end'?: number;
    /**
     * Zero-based index of the item of the sentences array representing the sentence in which the occurrence of the information was found
     * @type {number}
     * @memberof TemporalInformationMatch
     */
    'sentence'?: number;
    /**
     * Present and true if the match was derived from other temporal information
     * @type {boolean}
     * @memberof TemporalInformationMatch
     */
    'derived'?: boolean;
    /**
     * In the case of derived time point, the value of the @id property of another information item representing the base time point
     * @type {string}
     * @memberof TemporalInformationMatch
     */
    'referenceTimePoint'?: string;
    /**
     * In the case of derived time point, the value of the @id property of another information item representing the time span that was added to or subtracted from the base time point
     * @type {string}
     * @memberof TemporalInformationMatch
     */
    'referenceTimeSpan'?: string;
    /**
     * In case of time spans with indefinite quantity, the portion of text expressing the quantity, for example \'some\'
     * @type {string}
     * @memberof TemporalInformationMatch
     */
    'indefiniteQuantity'?: string;
    /**
     * In case of time spans that represent a duration, the portion of text expressing the duration, for example \'for\'
     * @type {string}
     * @memberof TemporalInformationMatch
     */
    'duration'?: string;
    /**
     * Portion of text corresponding to the information occurrence
     * @type {string}
     * @memberof TemporalInformationMatch
     */
    'text'?: string;
}
/**
 * Detector\'s response
 * @export
 * @interface TemporalInformationResponse
 */
export interface TemporalInformationResponse {
    /**
     * Success flag
     * @type {boolean}
     * @memberof TemporalInformationResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ServiceError}
     * @memberof TemporalInformationResponse
     */
    'error'?: ServiceError;
    /**
     * 
     * @type {DetectorBaseDocument & TemporalInformationDocument}
     * @memberof TemporalInformationResponse
     */
    'data'?: DetectorBaseDocument & TemporalInformationDocument;
}
/**
 * Token info
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * Zero-based position of the first character of the token
     * @type {number}
     * @memberof Token
     */
    'start'?: number;
    /**
     * Zero-based position of the first character after the token
     * @type {number}
     * @memberof Token
     */
    'end'?: number;
    /**
     * Expert.ai type
     * @type {string}
     * @memberof Token
     */
    'type'?: string;
    /**
     * <a href=\'https://universaldependencies.org/u/pos/\'>Universal Dependencies part-of-speech tag</a>
     * @type {string}
     * @memberof Token
     */
    'pos'?: string;
    /**
     * Lemma
     * @type {string}
     * @memberof Token
     */
    'lemma'?: string;
    /**
     * ID used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof Token
     */
    'syncon'?: number;
    /**
     * 
     * @type {VirtualSyncon}
     * @memberof Token
     */
    'vsyn'?: VirtualSyncon;
    /**
     * A semicolon separated list of <a href=\'https://universaldependencies.org/format.html#morphological-annotation\'>CoNLL-U format</a> morphological features
     * @type {string}
     * @memberof Token
     */
    'morphology'?: string;
    /**
     * 
     * @type {Dependency}
     * @memberof Token
     */
    'dependency'?: Dependency;
    /**
     * Atoms that make up the token
     * @type {Array<Atom>}
     * @memberof Token
     */
    'atoms'?: Array<Atom>;
    /**
     * Paragraph index in the `paragraphs` array
     * @type {number}
     * @memberof Token
     */
    'paragraph'?: number;
    /**
     * Sentence index in the `sentences` array
     * @type {number}
     * @memberof Token
     */
    'sentence'?: number;
    /**
     * Phrase index in the `phrases` array
     * @type {number}
     * @memberof Token
     */
    'phrase'?: number;
}
/**
 * A concept that does not exist in the Knowledge Graph but heuristics recognized as a type of a known parent concept.
 * @export
 * @interface VirtualSyncon
 */
export interface VirtualSyncon {
    /**
     * ID used to mark all the occurrences of the virtual concept in the text
     * @type {number}
     * @memberof VirtualSyncon
     */
    'id'?: number;
    /**
     * Parent concept; ID is used to look up Knowledge Graph data in the `knowledge` array
     * @type {number}
     * @memberof VirtualSyncon
     */
    'parent'?: number;
}
/**
 * Writeprint Specific Document properties
 * @export
 * @interface WriteprintDocument
 */
export interface WriteprintDocument {
    /**
     * 
     * @type {WriteprintExtraData}
     * @memberof WriteprintDocument
     */
    'extraData'?: WriteprintExtraData;
}
/**
 * Writeprint Extra Data
 * @export
 * @interface WriteprintExtraData
 */
export interface WriteprintExtraData {
    /**
     * 
     * @type {WriteprintJSONLD}
     * @memberof WriteprintExtraData
     */
    'JSON-LD'?: WriteprintJSONLD;
}
/**
 * JSON-LD format output
 * @export
 * @interface WriteprintJSONLD
 */
export interface WriteprintJSONLD {
    /**
     * JSON-LD context
     * @type {any}
     * @memberof WriteprintJSONLD
     */
    '@context'?: any;
    /**
     * JSON-LD graph data
     * @type {Array<WriteprintJSONLDGraph>}
     * @memberof WriteprintJSONLD
     */
    '@graph'?: Array<WriteprintJSONLDGraph>;
}
/**
 * 
 * @export
 * @interface WriteprintJSONLDGraph
 */
export interface WriteprintJSONLDGraph {
    /**
     * 
     * @type {string}
     * @memberof WriteprintJSONLDGraph
     */
    '@type'?: string;
    /**
     * 
     * @type {Array<ReadabilityIndex>}
     * @memberof WriteprintJSONLDGraph
     */
    'readabilityIndexes'?: Array<ReadabilityIndex>;
    /**
     * 
     * @type {WriteptintGraphStructuredIntexes}
     * @memberof WriteprintJSONLDGraph
     */
    'structureIndexes'?: WriteptintGraphStructuredIntexes;
}
/**
 * Detector\'s response
 * @export
 * @interface WriteprintResponse
 */
export interface WriteprintResponse {
    /**
     * Success flag
     * @type {boolean}
     * @memberof WriteprintResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ServiceError}
     * @memberof WriteprintResponse
     */
    'error'?: ServiceError;
    /**
     * 
     * @type {DetectorBaseDocument & WriteprintDocument}
     * @memberof WriteprintResponse
     */
    'data'?: DetectorBaseDocument & WriteprintDocument;
}
/**
 * 
 * @export
 * @interface WriteptintGraphStructuredIntexes
 */
export interface WriteptintGraphStructuredIntexes {
    /**
     * 
     * @type {CounterIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'sentences'?: CounterIndex;
    /**
     * 
     * @type {CounterIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'tokens'?: CounterIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'tokenLengthPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {CounterIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'verbTypes'?: CounterIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'charactersPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'atomsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'tokensPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'phrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'verbTypesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'smallFirstLetterSentences'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'capitalFirstLetterSentences'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'adjectivesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'adverbsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'articlesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'auxiliariesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'conjunctionsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'nounsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'properNounsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'punctuationPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'prepositionsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'pronounsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'particlesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'verbsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'namedEntitiesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'adjectivePhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'conjunctionPhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'adverbPhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'nounPhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'nominalPredicatesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'prepositionPhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'relativePhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'verbPhrasesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'emoticonsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'dotsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'multipleDotsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'questionMarksPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'multipleQuestionMarksPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'exclamationMarksPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'multipleExclamationMarksPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'exclamationMarkQuestionMarkSequencesPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'commasPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'colonsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'semicolonsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'singleQuotationMarksPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'doubleQuotationMarksPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'unknownConceptsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'functionWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'commonlyMisspelledWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'mostCommonWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'academicLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'businessLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'crimeLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'laymanLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'legalLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'militaryLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'politicalLanguageWordsPerSentence'?: PerSentenceIndex;
    /**
     * 
     * @type {PerSentenceIndex}
     * @memberof WriteptintGraphStructuredIntexes
     */
    'socialMediaLanguageWordsPerSentence'?: PerSentenceIndex;
}

/**
 * DocumentAnalysisApi - axios parameter creator
 * @export
 */
export const DocumentAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul> 
         * @summary Specific partial analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguageAnalysisPost: async (context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysis: 'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations', analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('analyzeContextLanguageAnalysisPost', 'context', context)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('analyzeContextLanguageAnalysisPost', 'language', language)
            // verify required parameter 'analysis' is not null or undefined
            assertParamExists('analyzeContextLanguageAnalysisPost', 'analysis', analysis)
            const localVarPath = `/analyze/{context}/{language}/{analysis}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"analysis"}}`, encodeURIComponent(String(analysis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Full analysis (i.e., sum of all available partial analyses) of the posted text
         * @summary Full analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguagePost: async (context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('analyzeContextLanguagePost', 'context', context)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('analyzeContextLanguagePost', 'language', language)
            const localVarPath = `/analyze/{context}/{language}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about available contexts
         * @summary Contexts information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentAnalysisApi - functional programming interface
 * @export
 */
export const DocumentAnalysisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentAnalysisApiAxiosParamCreator(configuration)
    return {
        /**
         * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul> 
         * @summary Specific partial analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeContextLanguageAnalysisPost(context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysis: 'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyzeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Full analysis (i.e., sum of all available partial analyses) of the posted text
         * @summary Full analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeContextLanguagePost(context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyzeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeContextLanguagePost(context, language, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information about available contexts
         * @summary Contexts information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentAnalysisApi - factory interface
 * @export
 */
export const DocumentAnalysisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentAnalysisApiFp(configuration)
    return {
        /**
         * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul> 
         * @summary Specific partial analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguageAnalysisPost(context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysis: 'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations', analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<AnalyzeResponse> {
            return localVarFp.analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Full analysis (i.e., sum of all available partial analyses) of the posted text
         * @summary Full analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguagePost(context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<AnalyzeResponse> {
            return localVarFp.analyzeContextLanguagePost(context, language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about available contexts
         * @summary Contexts information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsGet(options?: any): AxiosPromise<ContextsResponse> {
            return localVarFp.contextsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentAnalysisApi - object-oriented interface
 * @export
 * @class DocumentAnalysisApi
 * @extends {BaseAPI}
 */
export class DocumentAnalysisApi extends BaseAPI {
    /**
     * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul> 
     * @summary Specific partial analysis
     * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
     * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
     * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAnalysisApi
     */
    public analyzeContextLanguageAnalysisPost(context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysis: 'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return DocumentAnalysisApiFp(this.configuration).analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Full analysis (i.e., sum of all available partial analyses) of the posted text
     * @summary Full analysis
     * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
     * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAnalysisApi
     */
    public analyzeContextLanguagePost(context: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return DocumentAnalysisApiFp(this.configuration).analyzeContextLanguagePost(context, language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information about available contexts
     * @summary Contexts information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAnalysisApi
     */
    public contextsGet(options?: AxiosRequestConfig) {
        return DocumentAnalysisApiFp(this.configuration).contextsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentClassificationApi - axios parameter creator
 * @export
 */
export const DocumentClassificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Classification of the posted text
         * @summary Emotional traits classification with extra data containing the main groups of emotions
         * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeEmotionalTraitsLanguagePost: async (language: 'en' | 'de', features: 'extradata', analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('categorizeEmotionalTraitsLanguagePost', 'language', language)
            // verify required parameter 'features' is not null or undefined
            assertParamExists('categorizeEmotionalTraitsLanguagePost', 'features', features)
            const localVarPath = `/categorize/emotional-traits/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GeoJSON classification of the posted text
         * @summary Classification
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeGeotaxLanguagePost: async (language: 'de' | 'en' | 'es' | 'fr' | 'it', features: 'extradata', analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('categorizeGeotaxLanguagePost', 'language', language)
            // verify required parameter 'features' is not null or undefined
            assertParamExists('categorizeGeotaxLanguagePost', 'features', features)
            const localVarPath = `/categorize/geotax/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Classification of the posted text
         * @summary Classification
         * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeTaxonomyLanguagePost: async (taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxonomy' is not null or undefined
            assertParamExists('categorizeTaxonomyLanguagePost', 'taxonomy', taxonomy)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('categorizeTaxonomyLanguagePost', 'language', language)
            const localVarPath = `/categorize/{taxonomy}/{language}`
                .replace(`{${"taxonomy"}}`, encodeURIComponent(String(taxonomy)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about available taxonomies
         * @summary Taxonomies information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/taxonomies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detailed information about a taxonomy for a given language
         * @summary Taxonomy tree
         * @param {string} taxonomy Taxonomy name
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesTaxonomyLanguageGet: async (taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxonomy' is not null or undefined
            assertParamExists('taxonomiesTaxonomyLanguageGet', 'taxonomy', taxonomy)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('taxonomiesTaxonomyLanguageGet', 'language', language)
            const localVarPath = `/taxonomies/{taxonomy}/{language}`
                .replace(`{${"taxonomy"}}`, encodeURIComponent(String(taxonomy)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentClassificationApi - functional programming interface
 * @export
 */
export const DocumentClassificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentClassificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Classification of the posted text
         * @summary Emotional traits classification with extra data containing the main groups of emotions
         * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categorizeEmotionalTraitsLanguagePost(language: 'en' | 'de', features: 'extradata', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmotionalTraitsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * GeoJSON classification of the posted text
         * @summary Classification
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categorizeGeotaxLanguagePost(language: 'de' | 'en' | 'es' | 'fr' | 'it', features: 'extradata', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTaxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categorizeGeotaxLanguagePost(language, features, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Classification of the posted text
         * @summary Classification
         * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categorizeTaxonomyLanguagePost(taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorizeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information about available taxonomies
         * @summary Taxonomies information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomiesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomiesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detailed information about a taxonomy for a given language
         * @summary Taxonomy tree
         * @param {string} taxonomy Taxonomy name
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxonomiesTaxonomyLanguageGet(taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxonomiesTaxonomyLanguageGet(taxonomy, language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentClassificationApi - factory interface
 * @export
 */
export const DocumentClassificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentClassificationApiFp(configuration)
    return {
        /**
         * Classification of the posted text
         * @summary Emotional traits classification with extra data containing the main groups of emotions
         * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeEmotionalTraitsLanguagePost(language: 'en' | 'de', features: 'extradata', analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<EmotionalTraitsResponse> {
            return localVarFp.categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * GeoJSON classification of the posted text
         * @summary Classification
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeGeotaxLanguagePost(language: 'de' | 'en' | 'es' | 'fr' | 'it', features: 'extradata', analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<GeoTaxResponse> {
            return localVarFp.categorizeGeotaxLanguagePost(language, features, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Classification of the posted text
         * @summary Classification
         * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeTaxonomyLanguagePost(taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<CategorizeResponse> {
            return localVarFp.categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about available taxonomies
         * @summary Taxonomies information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesGet(options?: any): AxiosPromise<TaxonomiesResponse> {
            return localVarFp.taxonomiesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Detailed information about a taxonomy for a given language
         * @summary Taxonomy tree
         * @param {string} taxonomy Taxonomy name
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesTaxonomyLanguageGet(taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', options?: any): AxiosPromise<TaxonomyResponse> {
            return localVarFp.taxonomiesTaxonomyLanguageGet(taxonomy, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentClassificationApi - object-oriented interface
 * @export
 * @class DocumentClassificationApi
 * @extends {BaseAPI}
 */
export class DocumentClassificationApi extends BaseAPI {
    /**
     * Classification of the posted text
     * @summary Emotional traits classification with extra data containing the main groups of emotions
     * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
     * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
     * @param {AnalysisRequest} [analysisRequest] The document to be classified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    public categorizeEmotionalTraitsLanguagePost(language: 'en' | 'de', features: 'extradata', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return DocumentClassificationApiFp(this.configuration).categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GeoJSON classification of the posted text
     * @summary Classification
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
     * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
     * @param {AnalysisRequest} [analysisRequest] The document to be classified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    public categorizeGeotaxLanguagePost(language: 'de' | 'en' | 'es' | 'fr' | 'it', features: 'extradata', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return DocumentClassificationApiFp(this.configuration).categorizeGeotaxLanguagePost(language, features, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Classification of the posted text
     * @summary Classification
     * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
     * @param {AnalysisRequest} [analysisRequest] The document to be classified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    public categorizeTaxonomyLanguagePost(taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return DocumentClassificationApiFp(this.configuration).categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information about available taxonomies
     * @summary Taxonomies information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    public taxonomiesGet(options?: AxiosRequestConfig) {
        return DocumentClassificationApiFp(this.configuration).taxonomiesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detailed information about a taxonomy for a given language
     * @summary Taxonomy tree
     * @param {string} taxonomy Taxonomy name
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    public taxonomiesTaxonomyLanguageGet(taxonomy: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', options?: AxiosRequestConfig) {
        return DocumentClassificationApiFp(this.configuration).taxonomiesTaxonomyLanguageGet(taxonomy, language, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InformationDetectionApi - axios parameter creator
 * @export
 */
export const InformationDetectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information detection on the posted text
         * @summary Information detection
         * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
         * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectDetectorLanguagePost: async (detector: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detector' is not null or undefined
            assertParamExists('detectDetectorLanguagePost', 'detector', detector)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('detectDetectorLanguagePost', 'language', language)
            const localVarPath = `/detect/{detector}/{language}`
                .replace(`{${"detector"}}`, encodeURIComponent(String(detector)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PII detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectPiiLanguagePost: async (language: string, analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('detectPiiLanguagePost', 'language', language)
            const localVarPath = `/detect/pii/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Temporal information detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectTemporalInformationLanguagePost: async (language: string, analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('detectTemporalInformationLanguagePost', 'language', language)
            const localVarPath = `/detect/temporal-information/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Writeprint detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectWriteprintLanguagePost: async (language: string, analysisRequest?: AnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('detectWriteprintLanguagePost', 'language', language)
            const localVarPath = `/detect/writeprint/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about available detectors
         * @summary Detectors information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectorsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InformationDetectionApi - functional programming interface
 * @export
 */
export const InformationDetectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InformationDetectionApiAxiosParamCreator(configuration)
    return {
        /**
         * Information detection on the posted text
         * @summary Information detection
         * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
         * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectDetectorLanguagePost(detector: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectDetectorLanguagePost(detector, language, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary PII detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectPiiLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PIIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectPiiLanguagePost(language, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Temporal information detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectTemporalInformationLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemporalInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectTemporalInformationLanguagePost(language, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Writeprint detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectWriteprintLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WriteprintResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectWriteprintLanguagePost(language, analysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information about available detectors
         * @summary Detectors information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectorsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetectorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectorsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InformationDetectionApi - factory interface
 * @export
 */
export const InformationDetectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InformationDetectionApiFp(configuration)
    return {
        /**
         * Information detection on the posted text
         * @summary Information detection
         * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
         * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectDetectorLanguagePost(detector: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<void> {
            return localVarFp.detectDetectorLanguagePost(detector, language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PII detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectPiiLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<PIIResponse> {
            return localVarFp.detectPiiLanguagePost(language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Temporal information detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectTemporalInformationLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<TemporalInformationResponse> {
            return localVarFp.detectTemporalInformationLanguagePost(language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Writeprint detection
         * @param {string} language 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectWriteprintLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: any): AxiosPromise<WriteprintResponse> {
            return localVarFp.detectWriteprintLanguagePost(language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about available detectors
         * @summary Detectors information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectorsGet(options?: any): AxiosPromise<DetectorsResponse> {
            return localVarFp.detectorsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InformationDetectionApi - object-oriented interface
 * @export
 * @class InformationDetectionApi
 * @extends {BaseAPI}
 */
export class InformationDetectionApi extends BaseAPI {
    /**
     * Information detection on the posted text
     * @summary Information detection
     * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
     * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    public detectDetectorLanguagePost(detector: string, language: 'de' | 'en' | 'es' | 'fr' | 'it', analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return InformationDetectionApiFp(this.configuration).detectDetectorLanguagePost(detector, language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PII detection
     * @param {string} language 
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    public detectPiiLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return InformationDetectionApiFp(this.configuration).detectPiiLanguagePost(language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Temporal information detection
     * @param {string} language 
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    public detectTemporalInformationLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return InformationDetectionApiFp(this.configuration).detectTemporalInformationLanguagePost(language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Writeprint detection
     * @param {string} language 
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    public detectWriteprintLanguagePost(language: string, analysisRequest?: AnalysisRequest, options?: AxiosRequestConfig) {
        return InformationDetectionApiFp(this.configuration).detectWriteprintLanguagePost(language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information about available detectors
     * @summary Detectors information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    public detectorsGet(options?: AxiosRequestConfig) {
        return InformationDetectionApiFp(this.configuration).detectorsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


